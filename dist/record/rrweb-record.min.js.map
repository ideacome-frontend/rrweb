{"version":3,"file":"rrweb-record.min.js","sources":["../../node_modules/tslib/tslib.es6.js","../../node_modules/rrweb-snapshot/es/rrweb-snapshot.js","../../src/types.ts","../../src/utils.ts","../../src/record/mutation.ts","../../src/record/observer.ts","../../src/record/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","var NodeType;\n(function (NodeType) {\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\n})(NodeType || (NodeType = {}));\n\nvar _id = 1;\nvar tagNameRegex = RegExp('[^a-z1-6-_]');\nfunction genId() {\n    return _id++;\n}\nfunction getValidTagName(tagName) {\n    var processedTagName = tagName.toLowerCase().trim();\n    if (tagNameRegex.test(processedTagName)) {\n        return 'div';\n    }\n    return processedTagName;\n}\nfunction getCssRulesString(s) {\n    try {\n        var rules = s.rules || s.cssRules;\n        return rules\n            ? Array.from(rules).reduce(function (prev, cur) { return prev + getCssRuleString(cur); }, '')\n            : null;\n    }\n    catch (error) {\n        return null;\n    }\n}\nfunction getCssRuleString(rule) {\n    return isCSSImportRule(rule)\n        ? getCssRulesString(rule.styleSheet) || ''\n        : rule.cssText;\n}\nfunction isCSSImportRule(rule) {\n    return 'styleSheet' in rule;\n}\nfunction extractOrigin(url) {\n    var origin;\n    if (url.indexOf('//') > -1) {\n        origin = url.split('/').slice(0, 3).join('/');\n    }\n    else {\n        origin = url.split('/')[0];\n    }\n    origin = origin.split('?')[0];\n    return origin;\n}\nvar URL_IN_CSS_REF = /url\\((?:'([^']*)'|\"([^\"]*)\"|([^)]*))\\)/gm;\nvar RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/).*/;\nvar DATA_URI = /^(data:)([\\w\\/\\+\\-]+);(charset=[\\w-]+|base64).*,(.*)/i;\nfunction absoluteToStylesheet(cssText, href) {\n    return (cssText || '').replace(URL_IN_CSS_REF, function (origin, path1, path2, path3) {\n        var filePath = path1 || path2 || path3;\n        if (!filePath) {\n            return origin;\n        }\n        if (!RELATIVE_PATH.test(filePath)) {\n            return \"url('\" + filePath + \"')\";\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\" + filePath + \")\";\n        }\n        if (filePath[0] === '/') {\n            return \"url('\" + (extractOrigin(href) + filePath) + \"')\";\n        }\n        var stack = href.split('/');\n        var parts = filePath.split('/');\n        stack.pop();\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\n            var part = parts_1[_i];\n            if (part === '.') {\n                continue;\n            }\n            else if (part === '..') {\n                stack.pop();\n            }\n            else {\n                stack.push(part);\n            }\n        }\n        return \"url('\" + stack.join('/') + \"')\";\n    });\n}\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === '') {\n        return attributeValue;\n    }\n    var srcsetValues = attributeValue.split(',');\n    var resultingSrcsetString = srcsetValues\n        .map(function (srcItem) {\n        var trimmedSrcItem = srcItem.trimLeft().trimRight();\n        var urlAndSize = trimmedSrcItem.split(' ');\n        if (urlAndSize.length === 2) {\n            var absUrl = absoluteToDoc(doc, urlAndSize[0]);\n            return absUrl + \" \" + urlAndSize[1];\n        }\n        else if (urlAndSize.length === 1) {\n            var absUrl = absoluteToDoc(doc, urlAndSize[0]);\n            return \"\" + absUrl;\n        }\n        return '';\n    })\n        .join(', ');\n    return resultingSrcsetString;\n}\nfunction absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === '') {\n        return attributeValue;\n    }\n    var a = doc.createElement('a');\n    a.href = attributeValue;\n    return a.href;\n}\nfunction isSVGElement(el) {\n    return el.tagName === 'svg' || el instanceof SVGElement;\n}\nfunction transformAttribute(doc, name, value) {\n    if (name === 'src' || (name === 'href' && value)) {\n        return absoluteToDoc(doc, value);\n    }\n    else if (name === 'srcset' && value) {\n        return getAbsoluteSrcsetString(doc, value);\n    }\n    else if (name === 'style' && value) {\n        return absoluteToStylesheet(value, location.href);\n    }\n    else {\n        return value;\n    }\n}\nfunction serializeNode(n, doc, blockClass, inlineStylesheet, maskInputOptions, recordCanvas) {\n    if (maskInputOptions === void 0) { maskInputOptions = {}; }\n    switch (n.nodeType) {\n        case n.DOCUMENT_NODE:\n            return {\n                type: NodeType.Document,\n                childNodes: []\n            };\n        case n.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType.DocumentType,\n                name: n.name,\n                publicId: n.publicId,\n                systemId: n.systemId\n            };\n        case n.ELEMENT_NODE:\n            var needBlock_1 = false;\n            if (typeof blockClass === 'string') {\n                needBlock_1 = n.classList.contains(blockClass);\n            }\n            else {\n                n.classList.forEach(function (className) {\n                    if (blockClass.test(className)) {\n                        needBlock_1 = true;\n                    }\n                });\n            }\n            var tagName = getValidTagName(n.tagName);\n            var attributes_1 = {};\n            for (var _i = 0, _a = Array.from(n.attributes); _i < _a.length; _i++) {\n                var _b = _a[_i], name = _b.name, value = _b.value;\n                attributes_1[name] = transformAttribute(doc, name, value);\n            }\n            if (tagName === 'link' && inlineStylesheet) {\n                var stylesheet = Array.from(doc.styleSheets).find(function (s) {\n                    return s.href === n.href;\n                });\n                var cssText = getCssRulesString(stylesheet);\n                if (cssText) {\n                    delete attributes_1.rel;\n                    delete attributes_1.href;\n                    attributes_1._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n                }\n            }\n            if (tagName === 'style' &&\n                n.sheet &&\n                !(n.innerText ||\n                    n.textContent ||\n                    '').trim().length) {\n                var cssText = getCssRulesString(n.sheet);\n                if (cssText) {\n                    attributes_1._cssText = absoluteToStylesheet(cssText, location.href);\n                }\n            }\n            if (tagName === 'input' ||\n                tagName === 'textarea' ||\n                tagName === 'select') {\n                var value = n.value;\n                if (attributes_1.type !== 'radio' &&\n                    attributes_1.type !== 'checkbox' &&\n                    attributes_1.type !== 'submit' &&\n                    attributes_1.type !== 'button' &&\n                    value) {\n                    attributes_1.value =\n                        maskInputOptions[attributes_1.type] ||\n                            maskInputOptions[tagName]\n                            ? '*'.repeat(value.length)\n                            : value;\n                }\n                else if (n.checked) {\n                    attributes_1.checked = n.checked;\n                }\n            }\n            if (tagName === 'option') {\n                var selectValue = n.parentElement;\n                if (attributes_1.value === selectValue.value) {\n                    attributes_1.selected = n.selected;\n                }\n            }\n            if (tagName === 'canvas' && recordCanvas) {\n                attributes_1.rr_dataURL = n.toDataURL();\n            }\n            if (tagName === 'audio' || tagName === 'video') {\n                attributes_1.rr_mediaState = n.paused\n                    ? 'paused'\n                    : 'played';\n            }\n            if (n.scrollLeft) {\n                attributes_1.rr_scrollLeft = n.scrollLeft;\n            }\n            if (n.scrollTop) {\n                attributes_1.rr_scrollTop = n.scrollTop;\n            }\n            if (needBlock_1) {\n                var _c = n.getBoundingClientRect(), width = _c.width, height = _c.height;\n                attributes_1.rr_width = width + \"px\";\n                attributes_1.rr_height = height + \"px\";\n            }\n            return {\n                type: NodeType.Element,\n                tagName: tagName,\n                attributes: attributes_1,\n                childNodes: [],\n                isSVG: isSVGElement(n) || undefined,\n                needBlock: needBlock_1\n            };\n        case n.TEXT_NODE:\n            var parentTagName = n.parentNode && n.parentNode.tagName;\n            var textContent = n.textContent;\n            var isStyle = parentTagName === 'STYLE' ? true : undefined;\n            if (isStyle && textContent) {\n                textContent = absoluteToStylesheet(textContent, location.href);\n            }\n            if (parentTagName === 'SCRIPT') {\n                textContent = 'SCRIPT_PLACEHOLDER';\n            }\n            return {\n                type: NodeType.Text,\n                textContent: textContent || '',\n                isStyle: isStyle\n            };\n        case n.CDATA_SECTION_NODE:\n            return {\n                type: NodeType.CDATA,\n                textContent: ''\n            };\n        case n.COMMENT_NODE:\n            return {\n                type: NodeType.Comment,\n                textContent: n.textContent || ''\n            };\n        default:\n            return false;\n    }\n}\nfunction serializeNodeWithId(n, doc, map, blockClass, skipChild, inlineStylesheet, maskInputOptions, recordCanvas) {\n    if (skipChild === void 0) { skipChild = false; }\n    if (inlineStylesheet === void 0) { inlineStylesheet = true; }\n    var _serializedNode = serializeNode(n, doc, blockClass, inlineStylesheet, maskInputOptions, recordCanvas || false);\n    if (!_serializedNode) {\n        console.warn(n, 'not serialized');\n        return null;\n    }\n    var id;\n    if ('__sn' in n) {\n        id = n.__sn.id;\n    }\n    else {\n        id = genId();\n    }\n    var serializedNode = Object.assign(_serializedNode, { id: id });\n    n.__sn = serializedNode;\n    map[id] = n;\n    var recordChild = !skipChild;\n    if (serializedNode.type === NodeType.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n    }\n    if ((serializedNode.type === NodeType.Document ||\n        serializedNode.type === NodeType.Element) &&\n        recordChild) {\n        for (var _i = 0, _a = Array.from(n.childNodes); _i < _a.length; _i++) {\n            var childN = _a[_i];\n            var serializedChildNode = serializeNodeWithId(childN, doc, map, blockClass, skipChild, inlineStylesheet, maskInputOptions, recordCanvas);\n            if (serializedChildNode) {\n                serializedNode.childNodes.push(serializedChildNode);\n            }\n        }\n    }\n    return serializedNode;\n}\nfunction snapshot(n, blockClass, inlineStylesheet, maskAllInputsOrOptions, recordCanvas) {\n    if (blockClass === void 0) { blockClass = 'rr-block'; }\n    if (inlineStylesheet === void 0) { inlineStylesheet = true; }\n    var idNodeMap = {};\n    var maskInputOptions = maskAllInputsOrOptions === true\n        ? {\n            color: true,\n            date: true,\n            'datetime-local': true,\n            email: true,\n            month: true,\n            number: true,\n            range: true,\n            search: true,\n            tel: true,\n            text: true,\n            time: true,\n            url: true,\n            week: true,\n            textarea: true,\n            select: true\n        }\n        : maskAllInputsOrOptions === false\n            ? {}\n            : maskAllInputsOrOptions;\n    return [\n        serializeNodeWithId(n, n, idNodeMap, blockClass, false, inlineStylesheet, maskInputOptions, recordCanvas),\n        idNodeMap,\n    ];\n}\nfunction visitSnapshot(node, onVisit) {\n    function walk(current) {\n        onVisit(current);\n        if (current.type === NodeType.Document ||\n            current.type === NodeType.Element) {\n            current.childNodes.forEach(walk);\n        }\n    }\n    walk(node);\n}\n\nvar commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\nfunction parse(css, options) {\n    if (options === void 0) { options = {}; }\n    var lineno = 1;\n    var column = 1;\n    function updatePosition(str) {\n        var lines = str.match(/\\n/g);\n        if (lines) {\n            lineno += lines.length;\n        }\n        var i = str.lastIndexOf('\\n');\n        column = i === -1 ? column + str.length : str.length - i;\n    }\n    function position() {\n        var start = { line: lineno, column: column };\n        return function (node) {\n            node.position = new Position(start);\n            whitespace();\n            return node;\n        };\n    }\n    var Position = (function () {\n        function Position(start) {\n            this.start = start;\n            this.end = { line: lineno, column: column };\n            this.source = options.source;\n        }\n        return Position;\n    }());\n    Position.prototype.content = css;\n    var errorsList = [];\n    function error(msg) {\n        var err = new Error(options.source + ':' + lineno + ':' + column + ': ' + msg);\n        err.reason = msg;\n        err.filename = options.source;\n        err.line = lineno;\n        err.column = column;\n        err.source = css;\n        if (options.silent) {\n            errorsList.push(err);\n        }\n        else {\n            throw err;\n        }\n    }\n    function stylesheet() {\n        var rulesList = rules();\n        return {\n            type: 'stylesheet',\n            stylesheet: {\n                source: options.source,\n                rules: rulesList,\n                parsingErrors: errorsList\n            }\n        };\n    }\n    function open() {\n        return match(/^{\\s*/);\n    }\n    function close() {\n        return match(/^}/);\n    }\n    function rules() {\n        var node;\n        var rules = [];\n        whitespace();\n        comments(rules);\n        while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n            if (node !== false) {\n                rules.push(node);\n                comments(rules);\n            }\n        }\n        return rules;\n    }\n    function match(re) {\n        var m = re.exec(css);\n        if (!m) {\n            return;\n        }\n        var str = m[0];\n        updatePosition(str);\n        css = css.slice(str.length);\n        return m;\n    }\n    function whitespace() {\n        match(/^\\s*/);\n    }\n    function comments(rules) {\n        if (rules === void 0) { rules = []; }\n        var c;\n        while ((c = comment())) {\n            if (c !== false) {\n                rules.push(c);\n            }\n            c = comment();\n        }\n        return rules;\n    }\n    function comment() {\n        var pos = position();\n        if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n            return;\n        }\n        var i = 2;\n        while ('' !== css.charAt(i) &&\n            ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))) {\n            ++i;\n        }\n        i += 2;\n        if ('' === css.charAt(i - 1)) {\n            return error('End of comment missing');\n        }\n        var str = css.slice(2, i - 2);\n        column += 2;\n        updatePosition(str);\n        css = css.slice(i);\n        column += 2;\n        return pos({\n            type: 'comment',\n            comment: str\n        });\n    }\n    function selector() {\n        var m = match(/^([^{]+)/);\n        if (!m) {\n            return;\n        }\n        return trim(m[0])\n            .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n            .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, function (m) {\n            return m.replace(/,/g, '\\u200C');\n        })\n            .split(/\\s*(?![^(]*\\)),\\s*/)\n            .map(function (s) {\n            return s.replace(/\\u200C/g, ',');\n        });\n    }\n    function declaration() {\n        var pos = position();\n        var propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n        if (!propMatch) {\n            return;\n        }\n        var prop = trim(propMatch[0]);\n        if (!match(/^:\\s*/)) {\n            return error(\"property missing ':'\");\n        }\n        var val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n        var ret = pos({\n            type: 'declaration',\n            property: prop.replace(commentre, ''),\n            value: val ? trim(val[0]).replace(commentre, '') : ''\n        });\n        match(/^[;\\s]*/);\n        return ret;\n    }\n    function declarations() {\n        var decls = [];\n        if (!open()) {\n            return error(\"missing '{'\");\n        }\n        comments(decls);\n        var decl;\n        while ((decl = declaration())) {\n            if (decl !== false) {\n                decls.push(decl);\n                comments(decls);\n            }\n            decl = declaration();\n        }\n        if (!close()) {\n            return error(\"missing '}'\");\n        }\n        return decls;\n    }\n    function keyframe() {\n        var m;\n        var vals = [];\n        var pos = position();\n        while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n            vals.push(m[1]);\n            match(/^,\\s*/);\n        }\n        if (!vals.length) {\n            return;\n        }\n        return pos({\n            type: 'keyframe',\n            values: vals,\n            declarations: declarations()\n        });\n    }\n    function atkeyframes() {\n        var pos = position();\n        var m = match(/^@([-\\w]+)?keyframes\\s*/);\n        if (!m) {\n            return;\n        }\n        var vendor = m[1];\n        m = match(/^([-\\w]+)\\s*/);\n        if (!m) {\n            return error('@keyframes missing name');\n        }\n        var name = m[1];\n        if (!open()) {\n            return error(\"@keyframes missing '{'\");\n        }\n        var frame;\n        var frames = comments();\n        while ((frame = keyframe())) {\n            frames.push(frame);\n            frames = frames.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@keyframes missing '}'\");\n        }\n        return pos({\n            type: 'keyframes',\n            name: name,\n            vendor: vendor,\n            keyframes: frames\n        });\n    }\n    function atsupports() {\n        var pos = position();\n        var m = match(/^@supports *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var supports = trim(m[1]);\n        if (!open()) {\n            return error(\"@supports missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@supports missing '}'\");\n        }\n        return pos({\n            type: 'supports',\n            supports: supports,\n            rules: style\n        });\n    }\n    function athost() {\n        var pos = position();\n        var m = match(/^@host\\s*/);\n        if (!m) {\n            return;\n        }\n        if (!open()) {\n            return error(\"@host missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@host missing '}'\");\n        }\n        return pos({\n            type: 'host',\n            rules: style\n        });\n    }\n    function atmedia() {\n        var pos = position();\n        var m = match(/^@media *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var media = trim(m[1]);\n        if (!open()) {\n            return error(\"@media missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@media missing '}'\");\n        }\n        return pos({\n            type: 'media',\n            media: media,\n            rules: style\n        });\n    }\n    function atcustommedia() {\n        var pos = position();\n        var m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n        if (!m) {\n            return;\n        }\n        return pos({\n            type: 'custom-media',\n            name: trim(m[1]),\n            media: trim(m[2])\n        });\n    }\n    function atpage() {\n        var pos = position();\n        var m = match(/^@page */);\n        if (!m) {\n            return;\n        }\n        var sel = selector() || [];\n        if (!open()) {\n            return error(\"@page missing '{'\");\n        }\n        var decls = comments();\n        var decl;\n        while ((decl = declaration())) {\n            decls.push(decl);\n            decls = decls.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@page missing '}'\");\n        }\n        return pos({\n            type: 'page',\n            selectors: sel,\n            declarations: decls\n        });\n    }\n    function atdocument() {\n        var pos = position();\n        var m = match(/^@([-\\w]+)?document *([^{]+)/);\n        if (!m) {\n            return;\n        }\n        var vendor = trim(m[1]);\n        var doc = trim(m[2]);\n        if (!open()) {\n            return error(\"@document missing '{'\");\n        }\n        var style = comments().concat(rules());\n        if (!close()) {\n            return error(\"@document missing '}'\");\n        }\n        return pos({\n            type: 'document',\n            document: doc,\n            vendor: vendor,\n            rules: style\n        });\n    }\n    function atfontface() {\n        var pos = position();\n        var m = match(/^@font-face\\s*/);\n        if (!m) {\n            return;\n        }\n        if (!open()) {\n            return error(\"@font-face missing '{'\");\n        }\n        var decls = comments();\n        var decl;\n        while ((decl = declaration())) {\n            decls.push(decl);\n            decls = decls.concat(comments());\n        }\n        if (!close()) {\n            return error(\"@font-face missing '}'\");\n        }\n        return pos({\n            type: 'font-face',\n            declarations: decls\n        });\n    }\n    var atimport = _compileAtrule('import');\n    var atcharset = _compileAtrule('charset');\n    var atnamespace = _compileAtrule('namespace');\n    function _compileAtrule(name) {\n        var re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n        return function () {\n            var pos = position();\n            var m = match(re);\n            if (!m) {\n                return;\n            }\n            var ret = { type: name };\n            ret[name] = m[1].trim();\n            return pos(ret);\n        };\n    }\n    function atrule() {\n        if (css[0] !== '@') {\n            return;\n        }\n        return (atkeyframes() ||\n            atmedia() ||\n            atcustommedia() ||\n            atsupports() ||\n            atimport() ||\n            atcharset() ||\n            atnamespace() ||\n            atdocument() ||\n            atpage() ||\n            athost() ||\n            atfontface());\n    }\n    function rule() {\n        var pos = position();\n        var sel = selector();\n        if (!sel) {\n            return error('selector missing');\n        }\n        comments();\n        return pos({\n            type: 'rule',\n            selectors: sel,\n            declarations: declarations()\n        });\n    }\n    return addParent(stylesheet());\n}\nfunction trim(str) {\n    return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\nfunction addParent(obj, parent) {\n    var isNode = obj && typeof obj.type === 'string';\n    var childParent = isNode ? obj : parent;\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var k = _a[_i];\n        var value = obj[k];\n        if (Array.isArray(value)) {\n            value.forEach(function (v) {\n                addParent(v, childParent);\n            });\n        }\n        else if (value && typeof value === 'object') {\n            addParent(value, childParent);\n        }\n    }\n    if (isNode) {\n        Object.defineProperty(obj, 'parent', {\n            configurable: true,\n            writable: true,\n            enumerable: false,\n            value: parent || null\n        });\n    }\n    return obj;\n}\n\nvar tagMap = {\n    script: 'noscript',\n    altglyph: 'altGlyph',\n    altglyphdef: 'altGlyphDef',\n    altglyphitem: 'altGlyphItem',\n    animatecolor: 'animateColor',\n    animatemotion: 'animateMotion',\n    animatetransform: 'animateTransform',\n    clippath: 'clipPath',\n    feblend: 'feBlend',\n    fecolormatrix: 'feColorMatrix',\n    fecomponenttransfer: 'feComponentTransfer',\n    fecomposite: 'feComposite',\n    feconvolvematrix: 'feConvolveMatrix',\n    fediffuselighting: 'feDiffuseLighting',\n    fedisplacementmap: 'feDisplacementMap',\n    fedistantlight: 'feDistantLight',\n    fedropshadow: 'feDropShadow',\n    feflood: 'feFlood',\n    fefunca: 'feFuncA',\n    fefuncb: 'feFuncB',\n    fefuncg: 'feFuncG',\n    fefuncr: 'feFuncR',\n    fegaussianblur: 'feGaussianBlur',\n    feimage: 'feImage',\n    femerge: 'feMerge',\n    femergenode: 'feMergeNode',\n    femorphology: 'feMorphology',\n    feoffset: 'feOffset',\n    fepointlight: 'fePointLight',\n    fespecularlighting: 'feSpecularLighting',\n    fespotlight: 'feSpotLight',\n    fetile: 'feTile',\n    feturbulence: 'feTurbulence',\n    foreignobject: 'foreignObject',\n    glyphref: 'glyphRef',\n    lineargradient: 'linearGradient',\n    radialgradient: 'radialGradient'\n};\nfunction getTagName(n) {\n    var tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n    if (tagName === 'link' && n.attributes._cssText) {\n        tagName = 'style';\n    }\n    return tagName;\n}\nvar HOVER_SELECTOR = /([^\\\\]):hover/g;\nfunction addHoverClass(cssText) {\n    var ast = parse(cssText, { silent: true });\n    if (!ast.stylesheet) {\n        return cssText;\n    }\n    ast.stylesheet.rules.forEach(function (rule) {\n        if ('selectors' in rule) {\n            (rule.selectors || []).forEach(function (selector) {\n                if (HOVER_SELECTOR.test(selector)) {\n                    var newSelector = selector.replace(HOVER_SELECTOR, '$1.\\\\:hover');\n                    cssText = cssText.replace(selector, selector + \", \" + newSelector);\n                }\n            });\n        }\n    });\n    return cssText;\n}\nfunction buildNode(n, doc, HACK_CSS) {\n    switch (n.type) {\n        case NodeType.Document:\n            return doc.implementation.createDocument(null, '', null);\n        case NodeType.DocumentType:\n            return doc.implementation.createDocumentType(n.name, n.publicId, n.systemId);\n        case NodeType.Element:\n            var tagName = getTagName(n);\n            var node_1;\n            if (n.isSVG) {\n                node_1 = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n            }\n            else {\n                node_1 = doc.createElement(tagName);\n            }\n            var _loop_1 = function (name) {\n                if (!n.attributes.hasOwnProperty(name)) {\n                    return \"continue\";\n                }\n                var value = n.attributes[name];\n                value =\n                    typeof value === 'boolean' || typeof value === 'number' ? '' : value;\n                if (!name.startsWith('rr_')) {\n                    var isTextarea = tagName === 'textarea' && name === 'value';\n                    var isRemoteOrDynamicCss = tagName === 'style' && name === '_cssText';\n                    if (isRemoteOrDynamicCss && HACK_CSS) {\n                        value = addHoverClass(value);\n                    }\n                    if (isTextarea || isRemoteOrDynamicCss) {\n                        var child = doc.createTextNode(value);\n                        for (var _i = 0, _a = Array.from(node_1.childNodes); _i < _a.length; _i++) {\n                            var c = _a[_i];\n                            if (c.nodeType === node_1.TEXT_NODE) {\n                                node_1.removeChild(c);\n                            }\n                        }\n                        node_1.appendChild(child);\n                        return \"continue\";\n                    }\n                    if (tagName === 'iframe' && name === 'src') {\n                        return \"continue\";\n                    }\n                    try {\n                        if (n.isSVG && name === 'xlink:href') {\n                            node_1.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n                        }\n                        else if (name === 'onload' ||\n                            name === 'onclick' ||\n                            name.substring(0, 7) === 'onmouse') {\n                            node_1.setAttribute('_' + name, value);\n                        }\n                        else {\n                            node_1.setAttribute(name, value);\n                        }\n                    }\n                    catch (error) {\n                    }\n                }\n                else {\n                    if (tagName === 'canvas' && name === 'rr_dataURL') {\n                        var image_1 = document.createElement('img');\n                        image_1.src = value;\n                        image_1.onload = function () {\n                            var ctx = node_1.getContext('2d');\n                            if (ctx) {\n                                ctx.drawImage(image_1, 0, 0, image_1.width, image_1.height);\n                            }\n                        };\n                    }\n                    if (name === 'rr_width') {\n                        node_1.style.width = value;\n                    }\n                    if (name === 'rr_height') {\n                        node_1.style.height = value;\n                    }\n                    if (name === 'rr_mediaState') {\n                        switch (value) {\n                            case 'played':\n                                node_1.play();\n                            case 'paused':\n                                node_1.pause();\n                                break;\n                            default:\n                        }\n                    }\n                }\n            };\n            for (var name in n.attributes) {\n                _loop_1(name);\n            }\n            return node_1;\n        case NodeType.Text:\n            return doc.createTextNode(n.isStyle && HACK_CSS ? addHoverClass(n.textContent) : n.textContent);\n        case NodeType.CDATA:\n            return doc.createCDATASection(n.textContent);\n        case NodeType.Comment:\n            return doc.createComment(n.textContent);\n        default:\n            return null;\n    }\n}\nfunction buildNodeWithSN(n, doc, map, skipChild, HACK_CSS) {\n    if (skipChild === void 0) { skipChild = false; }\n    if (HACK_CSS === void 0) { HACK_CSS = true; }\n    var node = buildNode(n, doc, HACK_CSS);\n    if (!node) {\n        return null;\n    }\n    if (n.type === NodeType.Document) {\n        doc.close();\n        doc.open();\n        node = doc;\n    }\n    node.__sn = n;\n    map[n.id] = node;\n    if ((n.type === NodeType.Document || n.type === NodeType.Element) &&\n        !skipChild) {\n        for (var _i = 0, _a = n.childNodes; _i < _a.length; _i++) {\n            var childN = _a[_i];\n            var childNode = buildNodeWithSN(childN, doc, map, false, HACK_CSS);\n            if (!childNode) {\n                console.warn('Failed to rebuild', childN);\n            }\n            else {\n                node.appendChild(childNode);\n            }\n        }\n    }\n    return node;\n}\nfunction visit(idNodeMap, onVisit) {\n    function walk(node) {\n        onVisit(node);\n    }\n    for (var key in idNodeMap) {\n        if (idNodeMap[key]) {\n            walk(idNodeMap[key]);\n        }\n    }\n}\nfunction handleScroll(node) {\n    var n = node.__sn;\n    if (n.type !== NodeType.Element) {\n        return;\n    }\n    var el = node;\n    for (var name in n.attributes) {\n        if (!(n.attributes.hasOwnProperty(name) && name.startsWith('rr_'))) {\n            continue;\n        }\n        var value = n.attributes[name];\n        if (name === 'rr_scrollLeft') {\n            el.scrollLeft = value;\n        }\n        if (name === 'rr_scrollTop') {\n            el.scrollTop = value;\n        }\n    }\n}\nfunction rebuild(n, doc, onVisit, HACK_CSS) {\n    if (HACK_CSS === void 0) { HACK_CSS = true; }\n    var idNodeMap = {};\n    var node = buildNodeWithSN(n, doc, idNodeMap, false, HACK_CSS);\n    visit(idNodeMap, function (visitedNode) {\n        if (onVisit) {\n            onVisit(visitedNode);\n        }\n        handleScroll(visitedNode);\n    });\n    return [node, idNodeMap];\n}\n\nexport { snapshot, serializeNodeWithId, rebuild, buildNodeWithSN, addHoverClass, transformAttribute, visitSnapshot, NodeType };\n","import {\n  serializedNodeWithId,\n  idNodeMap,\n  INode,\n  MaskInputOptions,\n} from 'rrweb-snapshot';\nimport { PackFn, UnpackFn } from './packer/base';\n\nexport enum EventType {\n  DomContentLoaded,\n  Load,\n  FullSnapshot,\n  IncrementalSnapshot,\n  Meta,\n  Custom,\n}\n\nexport type domContentLoadedEvent = {\n  type: EventType.DomContentLoaded;\n  data: {};\n};\n\nexport type loadedEvent = {\n  type: EventType.Load;\n  data: {};\n};\n\nexport type fullSnapshotEvent = {\n  type: EventType.FullSnapshot;\n  data: {\n    node: serializedNodeWithId;\n    initialOffset: {\n      top: number;\n      left: number;\n    };\n  };\n};\n\nexport type incrementalSnapshotEvent = {\n  type: EventType.IncrementalSnapshot;\n  data: incrementalData;\n};\n\nexport type metaEvent = {\n  type: EventType.Meta;\n  data: {\n    href: string;\n    width: number;\n    height: number;\n  };\n};\n\nexport type customEvent<T = unknown> = {\n  type: EventType.Custom;\n  data: {\n    tag: string;\n    payload: T;\n  };\n};\n\nexport type styleSheetEvent = {};\n\nexport enum IncrementalSource {\n  Mutation,\n  MouseMove,\n  MouseInteraction,\n  Scroll,\n  ViewportResize,\n  Input,\n  TouchMove,\n  MediaInteraction,\n  StyleSheetRule,\n  CanvasMutation,\n}\n\nexport type mutationData = {\n  source: IncrementalSource.Mutation;\n} & mutationCallbackParam;\n\nexport type mousemoveData = {\n  source: IncrementalSource.MouseMove | IncrementalSource.TouchMove;\n  positions: mousePosition[];\n};\n\nexport type mouseInteractionData = {\n  source: IncrementalSource.MouseInteraction;\n} & mouseInteractionParam;\n\nexport type scrollData = {\n  source: IncrementalSource.Scroll;\n} & scrollPosition;\n\nexport type viewportResizeData = {\n  source: IncrementalSource.ViewportResize;\n} & viewportResizeDimention;\n\nexport type inputData = {\n  source: IncrementalSource.Input;\n  id: number;\n} & inputValue;\n\nexport type mediaInteractionData = {\n  source: IncrementalSource.MediaInteraction;\n} & mediaInteractionParam;\n\nexport type styleSheetRuleData = {\n  source: IncrementalSource.StyleSheetRule;\n} & styleSheetRuleParam;\n\nexport type canvasMutationData = {\n  source: IncrementalSource.CanvasMutation;\n} & canvasMutationParam;\n\nexport type incrementalData =\n  | mutationData\n  | mousemoveData\n  | mouseInteractionData\n  | scrollData\n  | viewportResizeData\n  | inputData\n  | mediaInteractionData\n  | styleSheetRuleData\n  | canvasMutationData;\n\nexport type event =\n  | domContentLoadedEvent\n  | loadedEvent\n  | fullSnapshotEvent\n  | incrementalSnapshotEvent\n  | metaEvent\n  | customEvent;\n\nexport type eventWithTime = event & {\n  timestamp: number;\n  delay?: number;\n};\n\nexport type blockClass = string | RegExp;\n\nexport type SamplingStrategy = Partial<{\n  /**\n   * false means not to record mouse/touch move events\n   * number is the throttle threshold of recording mouse/touch move\n   */\n  mousemove: boolean | number;\n  /**\n   * false means not to record mouse interaction events\n   * can also specify record some kinds of mouse interactions\n   */\n  mouseInteraction: boolean | Record<string, boolean | undefined>;\n  /**\n   * number is the throttle threshold of recording scroll\n   */\n  scroll: number;\n  /**\n   * 'all' will record all the input events\n   * 'last' will only record the last input value while input a sequence of chars\n   */\n  input: 'all' | 'last';\n}>;\n\nexport type recordOptions<T> = {\n  emit?: (e: T, isCheckout?: boolean) => void;\n  checkoutEveryNth?: number;\n  checkoutEveryNms?: number;\n  blockClass?: blockClass;\n  ignoreClass?: string;\n  maskAllInputs?: boolean;\n  maskInputOptions?: MaskInputOptions;\n  inlineStylesheet?: boolean;\n  hooks?: hooksParam;\n  packFn?: PackFn;\n  sampling?: SamplingStrategy;\n  recordCanvas?: boolean;\n  // departed, please use sampling options\n  mousemoveWait?: number;\n};\n\nexport type observerParam = {\n  mutationCb: mutationCallBack;\n  mousemoveCb: mousemoveCallBack;\n  mouseInteractionCb: mouseInteractionCallBack;\n  scrollCb: scrollCallback;\n  viewportResizeCb: viewportResizeCallback;\n  inputCb: inputCallback;\n  mediaInteractionCb: mediaInteractionCallback;\n  blockClass: blockClass;\n  ignoreClass: string;\n  maskInputOptions: MaskInputOptions;\n  inlineStylesheet: boolean;\n  styleSheetRuleCb: styleSheetRuleCallback;\n  canvasMutationCb: canvasMutationCallback;\n  sampling: SamplingStrategy;\n  recordCanvas: boolean;\n};\n\nexport type hooksParam = {\n  mutation?: mutationCallBack;\n  mousemove?: mousemoveCallBack;\n  mouseInteraction?: mouseInteractionCallBack;\n  scroll?: scrollCallback;\n  viewportResize?: viewportResizeCallback;\n  input?: inputCallback;\n  mediaInteaction?: mediaInteractionCallback;\n  styleSheetRule?: styleSheetRuleCallback;\n  canvasMutation?: canvasMutationCallback;\n};\n\n// https://dom.spec.whatwg.org/#interface-mutationrecord\nexport type mutationRecord = {\n  type: string;\n  target: Node;\n  oldValue: string | null;\n  addedNodes: NodeList;\n  removedNodes: NodeList;\n  attributeName: string | null;\n};\n\nexport type textCursor = {\n  node: Node;\n  value: string | null;\n};\nexport type textMutation = {\n  id: number;\n  value: string | null;\n};\n\nexport type attributeCursor = {\n  node: Node;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\nexport type attributeMutation = {\n  id: number;\n  attributes: {\n    [key: string]: string | null;\n  };\n};\n\nexport type removedNodeMutation = {\n  parentId: number;\n  id: number;\n};\n\nexport type addedNodeMutation = {\n  parentId: number;\n  // Newly recorded mutations will not have previousId any more, just for compatibility\n  previousId?: number | null;\n  nextId: number | null;\n  node: serializedNodeWithId;\n};\n\ntype mutationCallbackParam = {\n  texts: textMutation[];\n  attributes: attributeMutation[];\n  removes: removedNodeMutation[];\n  adds: addedNodeMutation[];\n};\n\nexport type mutationCallBack = (m: mutationCallbackParam) => void;\n\nexport type mousemoveCallBack = (\n  p: mousePosition[],\n  source: IncrementalSource.MouseMove | IncrementalSource.TouchMove,\n) => void;\n\nexport type mousePosition = {\n  x: number;\n  y: number;\n  id: number;\n  timeOffset: number;\n};\n\nexport enum MouseInteractions {\n  MouseUp,\n  MouseDown,\n  Click,\n  ContextMenu,\n  DblClick,\n  Focus,\n  Blur,\n  TouchStart,\n  TouchMove_Departed, // we will start a separate observer for touch move event\n  TouchEnd,\n}\n\ntype mouseInteractionParam = {\n  type: MouseInteractions;\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type mouseInteractionCallBack = (d: mouseInteractionParam) => void;\n\nexport type scrollPosition = {\n  id: number;\n  x: number;\n  y: number;\n};\n\nexport type scrollCallback = (p: scrollPosition) => void;\n\nexport type styleSheetAddRule = {\n  rule: string;\n  index?: number;\n};\n\nexport type styleSheetDeleteRule = {\n  index: number;\n};\n\nexport type styleSheetRuleParam = {\n  id: number;\n  removes?: styleSheetDeleteRule[];\n  adds?: styleSheetAddRule[];\n};\n\nexport type styleSheetRuleCallback = (s: styleSheetRuleParam) => void;\n\nexport type canvasMutationCallback = (p: canvasMutationParam) => void;\n\nexport type canvasMutationParam = {\n  id: number;\n  property: string;\n  args: Array<unknown>;\n  setter?: true;\n};\n\nexport type viewportResizeDimention = {\n  width: number;\n  height: number;\n};\n\nexport type viewportResizeCallback = (d: viewportResizeDimention) => void;\n\nexport type inputValue = {\n  text: string;\n  isChecked: boolean;\n};\n\nexport type inputCallback = (v: inputValue & { id: number }) => void;\n\nexport const enum MediaInteractions {\n  Play,\n  Pause,\n}\n\nexport type mediaInteractionParam = {\n  type: MediaInteractions;\n  id: number;\n};\n\nexport type mediaInteractionCallback = (p: mediaInteractionParam) => void;\n\nexport type Mirror = {\n  map: idNodeMap;\n  getId: (n: INode) => number;\n  getNode: (id: number) => INode | null;\n  removeNodeFromMap: (n: INode) => void;\n  has: (id: number) => boolean;\n};\n\nexport type throttleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\nexport type listenerHandler = () => void;\nexport type hookResetter = () => void;\n\nexport type playerConfig = {\n  speed: number;\n  root: Element;\n  loadTimeout: number;\n  skipInactive: boolean;\n  showWarning: boolean;\n  showDebug: boolean;\n  blockClass: string;\n  liveMode: boolean;\n  insertStyleRules: string[];\n  triggerFocus: boolean;\n  UNSAFE_replayCanvas: boolean;\n  unpackFn?: UnpackFn;\n};\n\nexport type playerMetaData = {\n  startTime: number;\n  endTime: number;\n  totalTime: number;\n};\n\nexport type missingNode = {\n  node: Node;\n  mutation: addedNodeMutation;\n};\nexport type missingNodeMap = {\n  [id: number]: missingNode;\n};\n\nexport type actionWithDelay = {\n  doAction: () => void;\n  delay: number;\n};\n\nexport type Handler = (event?: unknown) => void;\n\nexport type Emitter = {\n  on(type: string, handler: Handler): void;\n  emit(type: string, event?: unknown): void;\n};\n\nexport type Arguments<T> = T extends (...payload: infer U) => unknown\n  ? U\n  : unknown;\n\nexport enum ReplayerEvents {\n  Start = 'start',\n  Pause = 'pause',\n  Resume = 'resume',\n  Resize = 'resize',\n  Finish = 'finish',\n  FullsnapshotRebuilded = 'fullsnapshot-rebuilded',\n  LoadStylesheetStart = 'load-stylesheet-start',\n  LoadStylesheetEnd = 'load-stylesheet-end',\n  SkipStart = 'skip-start',\n  SkipEnd = 'skip-end',\n  MouseInteraction = 'mouse-interaction',\n  EventCast = 'event-cast',\n  CustomEvent = 'custom-event',\n  Flush = 'flush',\n  StateChange = 'state-change',\n}\n","import {\n  Mirror,\n  throttleOptions,\n  listenerHandler,\n  hookResetter,\n  blockClass,\n  eventWithTime,\n  EventType,\n  IncrementalSource,\n  addedNodeMutation,\n  removedNodeMutation,\n  textMutation,\n  attributeMutation,\n  mutationData,\n  scrollData,\n  inputData,\n} from './types';\nimport { INode } from 'rrweb-snapshot';\n\nexport function on(\n  type: string,\n  fn: EventListenerOrEventListenerObject,\n  target: Document | Window = document,\n): listenerHandler {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\n\nexport const mirror: Mirror = {\n  map: {},\n  getId(n) {\n    // if n is not a serialized INode, use -1 as its id.\n    if (!n.__sn) {\n      return -1;\n    }\n    return n.__sn.id;\n  },\n  getNode(id) {\n    return mirror.map[id] || null;\n  },\n  // TODO: use a weakmap to get rid of manually memory management\n  removeNodeFromMap(n) {\n    const id = n.__sn && n.__sn.id;\n    delete mirror.map[id];\n    if (n.childNodes) {\n      n.childNodes.forEach((child) =>\n        mirror.removeNodeFromMap((child as Node) as INode),\n      );\n    }\n  },\n  has(id) {\n    return mirror.map.hasOwnProperty(id);\n  },\n};\n\n// copy from underscore and modified\nexport function throttle<T>(\n  func: (arg: T) => void,\n  wait: number,\n  options: throttleOptions = {},\n) {\n  let timeout: number | null = null;\n  let previous = 0;\n  // tslint:disable-next-line: only-arrow-functions\n  return function (arg: T) {\n    let now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    let remaining = wait - (now - previous);\n    let context = this;\n    let args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        window.clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = window.setTimeout(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n\nexport function hookSetter<T>(\n  target: T,\n  key: string | number | symbol,\n  d: PropertyDescriptor,\n  isRevoked?: boolean,\n  win = window,\n): hookResetter {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked\n      ? d\n      : {\n          set(value) {\n            // put hooked setter into event loop to avoid of set latency\n            setTimeout(() => {\n              d.set!.call(this, value);\n            }, 0);\n            if (original && original.set) {\n              original.set.call(this, value);\n            }\n          },\n        },\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\n\n// copy from https://github.com/getsentry/sentry-javascript/blob/b2109071975af8bf0316d3b5b38f519bdaf5dc15/packages/utils/src/object.ts\nexport function patch(\n  // tslint:disable-next-line:no-any\n  source: { [key: string]: any },\n  name: string,\n  // tslint:disable-next-line:no-any\n  replacement: (...args: any[]) => any,\n): () => void {\n  try {\n    if (!(name in source)) {\n      return () => {};\n    }\n\n    const original = source[name] as () => unknown;\n    const wrapped = replacement(original);\n\n    // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n    // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n    // tslint:disable-next-line:strict-type-predicates\n    if (typeof wrapped === 'function') {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original,\n        },\n      });\n    }\n\n    source[name] = wrapped;\n\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {};\n    // This can throw if multiple fill happens on a global object like XMLHttpRequest\n    // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n  }\n}\n\nexport function getWindowHeight(): number {\n  return (\n    window.innerHeight ||\n    (document.documentElement && document.documentElement.clientHeight) ||\n    (document.body && document.body.clientHeight)\n  );\n}\n\nexport function getWindowWidth(): number {\n  return (\n    window.innerWidth ||\n    (document.documentElement && document.documentElement.clientWidth) ||\n    (document.body && document.body.clientWidth)\n  );\n}\n\nexport function isBlocked(node: Node | null, blockClass: blockClass): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    let needBlock = false;\n    if (typeof blockClass === 'string') {\n      needBlock = (node as HTMLElement).classList.contains(blockClass);\n    } else {\n      (node as HTMLElement).classList.forEach((className) => {\n        if (blockClass.test(className)) {\n          needBlock = true;\n        }\n      });\n    }\n    return needBlock || isBlocked(node.parentNode, blockClass);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return isBlocked(node.parentNode, blockClass);\n  }\n  return isBlocked(node.parentNode, blockClass);\n}\n\nexport function isAncestorRemoved(target: INode): boolean {\n  const id = mirror.getId(target);\n  if (!mirror.has(id)) {\n    return true;\n  }\n  if (\n    target.parentNode &&\n    target.parentNode.nodeType === target.DOCUMENT_NODE\n  ) {\n    return false;\n  }\n  // if the root is not document, it means the node is not in the DOM tree anymore\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved((target.parentNode as unknown) as INode);\n}\n\nexport function isTouchEvent(\n  event: MouseEvent | TouchEvent,\n): event is TouchEvent {\n  return Boolean((event as TouchEvent).changedTouches);\n}\n\nexport function polyfill() {\n  if ('NodeList' in window && !NodeList.prototype.forEach) {\n    NodeList.prototype.forEach = (Array.prototype\n      .forEach as unknown) as NodeList['forEach'];\n  }\n}\n\nexport function needCastInSyncMode(event: eventWithTime): boolean {\n  switch (event.type) {\n    case EventType.DomContentLoaded:\n    case EventType.Load:\n    case EventType.Custom:\n      return false;\n    case EventType.FullSnapshot:\n    case EventType.Meta:\n      return true;\n    default:\n      break;\n  }\n\n  switch (event.data.source) {\n    case IncrementalSource.MouseMove:\n    case IncrementalSource.MouseInteraction:\n    case IncrementalSource.TouchMove:\n    case IncrementalSource.MediaInteraction:\n      return false;\n    case IncrementalSource.ViewportResize:\n    case IncrementalSource.StyleSheetRule:\n    case IncrementalSource.Scroll:\n    case IncrementalSource.Input:\n      return true;\n    default:\n      break;\n  }\n\n  return true;\n}\n\nexport type TreeNode = {\n  id: number;\n  mutation: addedNodeMutation;\n  parent?: TreeNode;\n  children: Record<number, TreeNode>;\n  texts: textMutation[];\n  attributes: attributeMutation[];\n};\nexport class TreeIndex {\n  public tree!: Record<number, TreeNode>;\n\n  private removeNodeMutations!: removedNodeMutation[];\n  private textMutations!: textMutation[];\n  private attributeMutations!: attributeMutation[];\n  private indexes!: Map<number, TreeNode>;\n  private removeIdSet!: Set<number>;\n  private scrollMap!: Map<number, scrollData>;\n  private inputMap!: Map<number, inputData>;\n\n  constructor() {\n    this.reset();\n  }\n\n  public add(mutation: addedNodeMutation) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode: TreeNode = {\n      id: mutation.node.id,\n      mutation,\n      children: [],\n      texts: [],\n      attributes: [],\n    };\n    if (!parentTreeNode) {\n      this.tree[treeNode.id] = treeNode;\n    } else {\n      treeNode.parent = parentTreeNode;\n      parentTreeNode.children[treeNode.id] = treeNode;\n    }\n    this.indexes.set(treeNode.id, treeNode);\n  }\n\n  public remove(mutation: removedNodeMutation) {\n    const parentTreeNode = this.indexes.get(mutation.parentId);\n    const treeNode = this.indexes.get(mutation.id);\n\n    const deepRemoveFromMirror = (id: number) => {\n      this.removeIdSet.add(id);\n      const node = mirror.getNode(id);\n      node?.childNodes.forEach((childNode) =>\n        deepRemoveFromMirror(((childNode as unknown) as INode).__sn.id),\n      );\n    };\n    const deepRemoveFromTreeIndex = (node: TreeNode) => {\n      this.removeIdSet.add(node.id);\n      Object.values(node.children).forEach((n) => deepRemoveFromTreeIndex(n));\n      const _treeNode = this.indexes.get(node.id);\n      if (_treeNode) {\n        const _parentTreeNode = _treeNode.parent;\n        if (_parentTreeNode) {\n          delete _treeNode.parent;\n          delete _parentTreeNode.children[_treeNode.id];\n          this.indexes.delete(mutation.id);\n        }\n      }\n    };\n\n    if (!treeNode) {\n      this.removeNodeMutations.push(mutation);\n      deepRemoveFromMirror(mutation.id);\n    } else if (!parentTreeNode) {\n      delete this.tree[treeNode.id];\n      this.indexes.delete(treeNode.id);\n      deepRemoveFromTreeIndex(treeNode);\n    } else {\n      delete treeNode.parent;\n      delete parentTreeNode.children[treeNode.id];\n      this.indexes.delete(mutation.id);\n      deepRemoveFromTreeIndex(treeNode);\n    }\n  }\n\n  public text(mutation: textMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.texts.push(mutation);\n    } else {\n      this.textMutations.push(mutation);\n    }\n  }\n\n  public attribute(mutation: attributeMutation) {\n    const treeNode = this.indexes.get(mutation.id);\n    if (treeNode) {\n      treeNode.attributes.push(mutation);\n    } else {\n      this.attributeMutations.push(mutation);\n    }\n  }\n\n  public scroll(d: scrollData) {\n    this.scrollMap.set(d.id, d);\n  }\n\n  public input(d: inputData) {\n    this.inputMap.set(d.id, d);\n  }\n\n  public flush(): {\n    mutationData: mutationData;\n    scrollMap: TreeIndex['scrollMap'];\n    inputMap: TreeIndex['inputMap'];\n  } {\n    const {\n      tree,\n      removeNodeMutations,\n      textMutations,\n      attributeMutations,\n    } = this;\n\n    const batchMutationData: mutationData = {\n      source: IncrementalSource.Mutation,\n      removes: removeNodeMutations,\n      texts: textMutations,\n      attributes: attributeMutations,\n      adds: [],\n    };\n\n    const walk = (treeNode: TreeNode, removed: boolean) => {\n      if (removed) {\n        this.removeIdSet.add(treeNode.id);\n      }\n      batchMutationData.texts = batchMutationData.texts\n        .concat(removed ? [] : treeNode.texts)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      batchMutationData.attributes = batchMutationData.attributes\n        .concat(removed ? [] : treeNode.attributes)\n        .filter((m) => !this.removeIdSet.has(m.id));\n      if (\n        !this.removeIdSet.has(treeNode.id) &&\n        !this.removeIdSet.has(treeNode.mutation.parentId) &&\n        !removed\n      ) {\n        batchMutationData.adds.push(treeNode.mutation);\n        if (treeNode.children) {\n          Object.values(treeNode.children).forEach((n) => walk(n, false));\n        }\n      } else {\n        Object.values(treeNode.children).forEach((n) => walk(n, true));\n      }\n    };\n\n    Object.values(tree).forEach((n) => walk(n, false));\n\n    for (const id of this.scrollMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.scrollMap.delete(id);\n      }\n    }\n    for (const id of this.inputMap.keys()) {\n      if (this.removeIdSet.has(id)) {\n        this.inputMap.delete(id);\n      }\n    }\n\n    const scrollMap = new Map(this.scrollMap);\n    const inputMap = new Map(this.inputMap);\n\n    this.reset();\n\n    return {\n      mutationData: batchMutationData,\n      scrollMap,\n      inputMap,\n    };\n  }\n\n  private reset() {\n    this.tree = [];\n    this.indexes = new Map();\n    this.removeNodeMutations = [];\n    this.textMutations = [];\n    this.attributeMutations = [];\n    this.removeIdSet = new Set();\n    this.scrollMap = new Map();\n    this.inputMap = new Map();\n  }\n}\n","import {\n  INode,\n  serializeNodeWithId,\n  transformAttribute,\n  MaskInputOptions,\n} from 'rrweb-snapshot';\nimport {\n  mutationRecord,\n  blockClass,\n  mutationCallBack,\n  textCursor,\n  attributeCursor,\n  removedNodeMutation,\n  addedNodeMutation,\n} from '../types';\nimport { mirror, isBlocked, isAncestorRemoved } from '../utils';\n\ntype DoubleLinkedListNode = {\n  previous: DoubleLinkedListNode | null;\n  next: DoubleLinkedListNode | null;\n  value: NodeInLinkedList;\n};\ntype NodeInLinkedList = Node & {\n  __ln: DoubleLinkedListNode;\n};\n\nfunction isNodeInLinkedList(n: Node | NodeInLinkedList): n is NodeInLinkedList {\n  return '__ln' in n;\n}\nclass DoubleLinkedList {\n  public length = 0;\n  public head: DoubleLinkedListNode | null = null;\n\n  public get(position: number) {\n    if (position >= this.length) {\n      throw new Error('Position outside of list range');\n    }\n\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n\n  public addNode(n: Node) {\n    const node: DoubleLinkedListNode = {\n      value: n as NodeInLinkedList,\n      previous: null,\n      next: null,\n    };\n    (n as NodeInLinkedList).__ln = node;\n    if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\n      const current = n.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n.previousSibling.__ln;\n      n.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n.nextSibling && isNodeInLinkedList(n.nextSibling)) {\n      const current = n.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n.nextSibling.__ln;\n      n.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    this.length++;\n  }\n\n  public removeNode(n: NodeInLinkedList) {\n    const current = n.__ln;\n    if (!this.head) {\n      return;\n    }\n\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      }\n    }\n    this.length--;\n  }\n}\n\nconst moveKey = (id: number, parentId: number) => `${id}@${parentId}`;\nfunction isINode(n: Node | INode): n is INode {\n  return '__sn' in n;\n}\n\n/**\n * controls behaviour of a MutationObserver\n */\nexport default class MutationBuffer {\n  private texts: textCursor[] = [];\n  private attributes: attributeCursor[] = [];\n  private removes: removedNodeMutation[] = [];\n  private adds: addedNodeMutation[] = [];\n\n  private movedMap: Record<string, true> = {};\n\n  /**\n   * the browser MutationObserver emits multiple mutations after\n   * a delay for performance reasons, making tracing added nodes hard\n   * in our `processMutations` callback function.\n   * For example, if we append an element el_1 into body, and then append\n   * another element el_2 into el_1, these two mutations may be passed to the\n   * callback function together when the two operations were done.\n   * Generally we need to trace child nodes of newly added nodes, but in this\n   * case if we count el_2 as el_1's child node in the first mutation record,\n   * then we will count el_2 again in the second mutation record which was\n   * duplicated.\n   * To avoid of duplicate counting added nodes, we use a Set to store\n   * added nodes and its child nodes during iterate mutation records. Then\n   * collect added nodes from the Set which have no duplicate copy. But\n   * this also causes newly added nodes will not be serialized with id ASAP,\n   * which means all the id related calculation should be lazy too.\n   */\n  private addedSet = new Set<Node>();\n  private movedSet = new Set<Node>();\n  private droppedSet = new Set<Node>();\n\n  private emissionCallback: mutationCallBack;\n  private blockClass: blockClass;\n  private inlineStylesheet: boolean;\n  private maskInputOptions: MaskInputOptions;\n  private recordCanvas: boolean;\n\n  constructor(\n    cb: mutationCallBack,\n    blockClass: blockClass,\n    inlineStylesheet: boolean,\n    maskInputOptions: MaskInputOptions,\n    recordCanvas: boolean,\n  ) {\n    this.blockClass = blockClass;\n    this.inlineStylesheet = inlineStylesheet;\n    this.maskInputOptions = maskInputOptions;\n    this.recordCanvas = recordCanvas;\n    this.emissionCallback = cb;\n  }\n\n  public processMutations = (mutations: mutationRecord[]) => {\n    mutations.forEach(this.processMutation);\n\n    /**\n     * Sometimes child node may be pushed before its newly added\n     * parent, so we init a queue to store these nodes.\n     */\n    const addList = new DoubleLinkedList();\n    const getNextId = (n: Node): number | null => {\n      let nextId =\n        n.nextSibling && mirror.getId((n.nextSibling as unknown) as INode);\n      if (nextId === -1 && isBlocked(n.nextSibling, this.blockClass)) {\n        nextId = null;\n      }\n      return nextId;\n    };\n    const pushAdd = (n: Node) => {\n      if (!n.parentNode) {\n        return;\n      }\n      const parentId = mirror.getId((n.parentNode as Node) as INode);\n      const nextId = getNextId(n);\n      if (parentId === -1 || nextId === -1) {\n        return addList.addNode(n);\n      }\n      this.adds.push({\n        parentId,\n        nextId,\n        node: serializeNodeWithId(\n          n,\n          document,\n          mirror.map,\n          this.blockClass,\n          true,\n          this.inlineStylesheet,\n          this.maskInputOptions,\n          this.recordCanvas,\n        )!,\n      });\n    };\n\n    for (const n of this.movedSet) {\n      pushAdd(n);\n    }\n\n    for (const n of this.addedSet) {\n      if (\n        !isAncestorInSet(this.droppedSet, n) &&\n        !isParentRemoved(this.removes, n)\n      ) {\n        pushAdd(n);\n      } else if (isAncestorInSet(this.movedSet, n)) {\n        pushAdd(n);\n      } else {\n        this.droppedSet.add(n);\n      }\n    }\n\n    let candidate: DoubleLinkedListNode | null = null;\n    while (addList.length) {\n      let node: DoubleLinkedListNode | null = null;\n      if (candidate) {\n        const parentId = mirror.getId(\n          (candidate.value.parentNode as Node) as INode,\n        );\n        const nextId = getNextId(candidate.value);\n        if (parentId !== -1 && nextId !== -1) {\n          node = candidate;\n        }\n      }\n      if (!node) {\n        for (let index = addList.length - 1; index >= 0; index--) {\n          const _node = addList.get(index)!;\n          const parentId = mirror.getId(\n            (_node.value.parentNode as Node) as INode,\n          );\n          const nextId = getNextId(_node.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = _node;\n            break;\n          }\n        }\n      }\n      if (!node) {\n        /**\n         * If all nodes in queue could not find a serialized parent,\n         * it may be a bug or corner case. We need to escape the\n         * dead while loop at once.\n         */\n        break;\n      }\n      candidate = node.previous;\n      addList.removeNode(node.value);\n      pushAdd(node.value);\n    }\n\n    this.emit();\n  };\n\n  public emit = () => {\n    const payload = {\n      texts: this.texts\n        .map((text) => ({\n          id: mirror.getId(text.node as INode),\n          value: text.value,\n        }))\n        // text mutation's id was not in the mirror map means the target node has been removed\n        .filter((text) => mirror.has(text.id)),\n      attributes: this.attributes\n        .map((attribute) => ({\n          id: mirror.getId(attribute.node as INode),\n          attributes: attribute.attributes,\n        }))\n        // attribute mutation's id was not in the mirror map means the target node has been removed\n        .filter((attribute) => mirror.has(attribute.id)),\n      removes: this.removes,\n      adds: this.adds,\n    };\n    // payload may be empty if the mutations happened in some blocked elements\n    if (\n      !payload.texts.length &&\n      !payload.attributes.length &&\n      !payload.removes.length &&\n      !payload.adds.length\n    ) {\n      return;\n    }\n    this.emissionCallback(payload);\n\n    // reset\n    this.texts = [];\n    this.attributes = [];\n    this.removes = [];\n    this.adds = [];\n    this.addedSet = new Set<Node>();\n    this.movedSet = new Set<Node>();\n    this.droppedSet = new Set<Node>();\n    this.movedMap = {};\n  };\n\n  private processMutation = (m: mutationRecord) => {\n    switch (m.type) {\n      case 'characterData': {\n        const value = m.target.textContent;\n        if (!isBlocked(m.target, this.blockClass) && value !== m.oldValue) {\n          this.texts.push({\n            value,\n            node: m.target,\n          });\n        }\n        break;\n      }\n      case 'attributes': {\n        const value = (m.target as HTMLElement).getAttribute(m.attributeName!);\n        if (isBlocked(m.target, this.blockClass) || value === m.oldValue) {\n          return;\n        }\n        let item: attributeCursor | undefined = this.attributes.find(\n          (a) => a.node === m.target,\n        );\n        if (!item) {\n          item = {\n            node: m.target,\n            attributes: {},\n          };\n          this.attributes.push(item);\n        }\n        // overwrite attribute if the mutations was triggered in same time\n        item.attributes[m.attributeName!] = transformAttribute(\n          document,\n          m.attributeName!,\n          value!,\n        );\n        break;\n      }\n      case 'childList': {\n        m.addedNodes.forEach((n) => this.genAdds(n, m.target));\n        m.removedNodes.forEach((n) => {\n          const nodeId = mirror.getId(n as INode);\n          const parentId = mirror.getId(m.target as INode);\n          if (\n            isBlocked(n, this.blockClass) ||\n            isBlocked(m.target, this.blockClass)\n          ) {\n            return;\n          }\n          // removed node has not been serialized yet, just remove it from the Set\n          if (this.addedSet.has(n)) {\n            deepDelete(this.addedSet, n);\n            this.droppedSet.add(n);\n          } else if (this.addedSet.has(m.target) && nodeId === -1) {\n            /**\n             * If target was newly added and removed child node was\n             * not serialized, it means the child node has been removed\n             * before callback fired, so we can ignore it because\n             * newly added node will be serialized without child nodes.\n             * TODO: verify this\n             */\n          } else if (isAncestorRemoved(m.target as INode)) {\n            /**\n             * If parent id was not in the mirror map any more, it\n             * means the parent node has already been removed. So\n             * the node is also removed which we do not need to track\n             * and replay.\n             */\n          } else if (\n            this.movedSet.has(n) &&\n            this.movedMap[moveKey(nodeId, parentId)]\n          ) {\n            deepDelete(this.movedSet, n);\n          } else {\n            this.removes.push({\n              parentId,\n              id: nodeId,\n            });\n          }\n          mirror.removeNodeFromMap(n as INode);\n        });\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  private genAdds = (n: Node | INode, target?: Node | INode) => {\n    if (isBlocked(n, this.blockClass)) {\n      return;\n    }\n    if (isINode(n)) {\n      this.movedSet.add(n);\n      let targetId: number | null = null;\n      if (target && isINode(target)) {\n        targetId = target.__sn.id;\n      }\n      if (targetId) {\n        this.movedMap[moveKey(n.__sn.id, targetId)] = true;\n      }\n    } else {\n      this.addedSet.add(n);\n      this.droppedSet.delete(n);\n    }\n    n.childNodes.forEach((childN) => this.genAdds(childN));\n  };\n}\n\n/**\n * Some utils to handle the mutation observer DOM records.\n * It should be more clear to extend the native data structure\n * like Set and Map, but currently Typescript does not support\n * that.\n */\nfunction deepDelete(addsSet: Set<Node>, n: Node) {\n  addsSet.delete(n);\n  n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\n}\n\nfunction isParentRemoved(removes: removedNodeMutation[], n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  const parentId = mirror.getId((parentNode as Node) as INode);\n  if (removes.some((r) => r.id === parentId)) {\n    return true;\n  }\n  return isParentRemoved(removes, parentNode);\n}\n\nfunction isAncestorInSet(set: Set<Node>, n: Node): boolean {\n  const { parentNode } = n;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return isAncestorInSet(set, parentNode);\n}\n","import { INode, MaskInputOptions } from 'rrweb-snapshot';\nimport {\n  mirror,\n  throttle,\n  on,\n  hookSetter,\n  getWindowHeight,\n  getWindowWidth,\n  isBlocked,\n  isTouchEvent,\n  patch,\n} from '../utils';\nimport {\n  mutationCallBack,\n  observerParam,\n  mousemoveCallBack,\n  mousePosition,\n  mouseInteractionCallBack,\n  MouseInteractions,\n  listenerHandler,\n  scrollCallback,\n  styleSheetRuleCallback,\n  viewportResizeCallback,\n  inputValue,\n  inputCallback,\n  hookResetter,\n  blockClass,\n  IncrementalSource,\n  hooksParam,\n  Arguments,\n  mediaInteractionCallback,\n  MediaInteractions,\n  SamplingStrategy,\n  canvasMutationCallback,\n} from '../types';\nimport MutationBuffer from './mutation';\n\nfunction initMutationObserver(\n  cb: mutationCallBack,\n  blockClass: blockClass,\n  inlineStylesheet: boolean,\n  maskInputOptions: MaskInputOptions,\n  recordCanvas: boolean,\n): MutationObserver {\n  // see mutation.ts for details\n  const mutationBuffer = new MutationBuffer(\n    cb,\n    blockClass,\n    inlineStylesheet,\n    maskInputOptions,\n    recordCanvas,\n  );\n  const observer = new MutationObserver(mutationBuffer.processMutations);\n  observer.observe(document, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n  });\n  return observer;\n}\n\nfunction initMoveObserver(\n  cb: mousemoveCallBack,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  if (sampling.mousemove === false) {\n    return () => {};\n  }\n\n  const threshold =\n    typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\n\n  let positions: mousePosition[] = [];\n  let timeBaseline: number | null;\n  const wrappedCb = throttle((isTouch: boolean) => {\n    const totalOffset = Date.now() - timeBaseline!;\n    cb(\n      positions.map((p) => {\n        p.timeOffset -= totalOffset;\n        return p;\n      }),\n      isTouch ? IncrementalSource.TouchMove : IncrementalSource.MouseMove,\n    );\n    positions = [];\n    timeBaseline = null;\n  }, 500);\n  const updatePosition = throttle<MouseEvent | TouchEvent>(\n    (evt) => {\n      const { target } = evt;\n      const { clientX, clientY } = isTouchEvent(evt)\n        ? evt.changedTouches[0]\n        : evt;\n      if (!timeBaseline) {\n        timeBaseline = Date.now();\n      }\n      positions.push({\n        x: clientX,\n        y: clientY,\n        id: mirror.getId(target as INode),\n        timeOffset: Date.now() - timeBaseline,\n      });\n      wrappedCb(isTouchEvent(evt));\n    },\n    threshold,\n    {\n      trailing: false,\n    },\n  );\n  const handlers = [\n    on('mousemove', updatePosition),\n    on('touchmove', updatePosition),\n  ];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initMouseInteractionObserver(\n  cb: mouseInteractionCallBack,\n  blockClass: blockClass,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  if (sampling.mouseInteraction === false) {\n    return () => {};\n  }\n  const disableMap: Record<string, boolean | undefined> =\n    sampling.mouseInteraction === true ||\n    sampling.mouseInteraction === undefined\n      ? {}\n      : sampling.mouseInteraction;\n\n  const handlers: listenerHandler[] = [];\n  const getHandler = (eventKey: keyof typeof MouseInteractions) => {\n    return (event: MouseEvent | TouchEvent) => {\n      if (isBlocked(event.target as Node, blockClass)) {\n        return;\n      }\n      const id = mirror.getId(event.target as INode);\n      const { clientX, clientY } = isTouchEvent(event)\n        ? event.changedTouches[0]\n        : event;\n      cb({\n        type: MouseInteractions[eventKey],\n        id,\n        x: clientX,\n        y: clientY,\n      });\n    };\n  };\n  Object.keys(MouseInteractions)\n    .filter(\n      (key) =>\n        Number.isNaN(Number(key)) &&\n        !key.endsWith('_Departed') &&\n        disableMap[key] !== false,\n    )\n    .forEach((eventKey: keyof typeof MouseInteractions) => {\n      const eventName = eventKey.toLowerCase();\n      const handler = getHandler(eventKey);\n      handlers.push(on(eventName, handler));\n    });\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initScrollObserver(\n  cb: scrollCallback,\n  blockClass: blockClass,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  const updatePosition = throttle<UIEvent>((evt) => {\n    if (!evt.target || isBlocked(evt.target as Node, blockClass)) {\n      return;\n    }\n    const id = mirror.getId(evt.target as INode);\n    if (evt.target === document) {\n      const scrollEl = (document.scrollingElement || document.documentElement)!;\n      cb({\n        id,\n        x: scrollEl.scrollLeft,\n        y: scrollEl.scrollTop,\n      });\n    } else {\n      cb({\n        id,\n        x: (evt.target as HTMLElement).scrollLeft,\n        y: (evt.target as HTMLElement).scrollTop,\n      });\n    }\n  }, sampling.scroll || 100);\n  return on('scroll', updatePosition);\n}\n\nfunction initViewportResizeObserver(\n  cb: viewportResizeCallback,\n): listenerHandler {\n  const updateDimension = throttle(() => {\n    const height = getWindowHeight();\n    const width = getWindowWidth();\n    cb({\n      width: Number(width),\n      height: Number(height),\n    });\n  }, 200);\n  return on('resize', updateDimension, window);\n}\n\nexport const INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\nconst lastInputValueMap: WeakMap<EventTarget, inputValue> = new WeakMap();\nfunction initInputObserver(\n  cb: inputCallback,\n  blockClass: blockClass,\n  ignoreClass: string,\n  maskInputOptions: MaskInputOptions,\n  sampling: SamplingStrategy,\n): listenerHandler {\n  function eventHandler(event: Event) {\n    const { target } = event;\n    if (\n      !target ||\n      !(target as Element).tagName ||\n      INPUT_TAGS.indexOf((target as Element).tagName) < 0 ||\n      isBlocked(target as Node, blockClass)\n    ) {\n      return;\n    }\n    const type: string | undefined = (target as HTMLInputElement).type;\n    if (\n      type === 'password' ||\n      (target as HTMLElement).classList.contains(ignoreClass)\n    ) {\n      return;\n    }\n    let text = (target as HTMLInputElement).value;\n    let isChecked = false;\n    if (type === 'radio' || type === 'checkbox') {\n      isChecked = (target as HTMLInputElement).checked;\n    } else if (\n      maskInputOptions[\n        (target as Element).tagName.toLowerCase() as keyof MaskInputOptions\n      ] ||\n      maskInputOptions[type as keyof MaskInputOptions]\n    ) {\n      text = '*'.repeat(text.length);\n    }\n    cbWithDedup(target, { text, isChecked });\n    // if a radio was checked\n    // the other radios with the same name attribute will be unchecked.\n    const name: string | undefined = (target as HTMLInputElement).name;\n    if (type === 'radio' && name && isChecked) {\n      document\n        .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\n        .forEach((el) => {\n          if (el !== target) {\n            cbWithDedup(el, {\n              text: (el as HTMLInputElement).value,\n              isChecked: !isChecked,\n            });\n          }\n        });\n    }\n  }\n  function cbWithDedup(target: EventTarget, v: inputValue) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (\n      !lastInputValue ||\n      lastInputValue.text !== v.text ||\n      lastInputValue.isChecked !== v.isChecked\n    ) {\n      lastInputValueMap.set(target, v);\n      const id = mirror.getId(target as INode);\n      cb({\n        ...v,\n        id,\n      });\n    }\n  }\n  const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\n  const handlers: Array<\n    listenerHandler | hookResetter\n  > = events.map((eventName) => on(eventName, eventHandler));\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(\n    HTMLInputElement.prototype,\n    'value',\n  );\n  const hookProperties: Array<[HTMLElement, string]> = [\n    [HTMLInputElement.prototype, 'value'],\n    [HTMLInputElement.prototype, 'checked'],\n    [HTMLSelectElement.prototype, 'value'],\n    [HTMLTextAreaElement.prototype, 'value'],\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map((p) =>\n        hookSetter<HTMLElement>(p[0], p[1], {\n          set() {\n            // mock to a normal event\n            eventHandler({ target: this } as Event);\n          },\n        }),\n      ),\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initStyleSheetObserver(cb: styleSheetRuleCallback): listenerHandler {\n  const insertRule = CSSStyleSheet.prototype.insertRule;\n  CSSStyleSheet.prototype.insertRule = function (rule: string, index?: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        adds: [{ rule, index }],\n      });\n    }\n    return insertRule.apply(this, arguments);\n  };\n\n  const deleteRule = CSSStyleSheet.prototype.deleteRule;\n  CSSStyleSheet.prototype.deleteRule = function (index: number) {\n    const id = mirror.getId(this.ownerNode as INode);\n    if (id !== -1) {\n      cb({\n        id,\n        removes: [{ index }],\n      });\n    }\n    return deleteRule.apply(this, arguments);\n  };\n\n  return () => {\n    CSSStyleSheet.prototype.insertRule = insertRule;\n    CSSStyleSheet.prototype.deleteRule = deleteRule;\n  };\n}\n\nfunction initMediaInteractionObserver(\n  mediaInteractionCb: mediaInteractionCallback,\n  blockClass: blockClass,\n): listenerHandler {\n  const handler = (type: 'play' | 'pause') => (event: Event) => {\n    const { target } = event;\n    if (!target || isBlocked(target as Node, blockClass)) {\n      return;\n    }\n    mediaInteractionCb({\n      type: type === 'play' ? MediaInteractions.Play : MediaInteractions.Pause,\n      id: mirror.getId(target as INode),\n    });\n  };\n  const handlers = [on('play', handler('play')), on('pause', handler('pause'))];\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction initCanvasMutationObserver(\n  cb: canvasMutationCallback,\n  blockClass: blockClass,\n): listenerHandler {\n  const props = Object.getOwnPropertyNames(CanvasRenderingContext2D.prototype);\n  const handlers: listenerHandler[] = [];\n  for (const prop of props) {\n    try {\n      if (\n        typeof CanvasRenderingContext2D.prototype[\n          prop as keyof CanvasRenderingContext2D\n        ] !== 'function'\n      ) {\n        continue;\n      }\n      const restoreHandler = patch(\n        CanvasRenderingContext2D.prototype,\n        prop,\n        function (original) {\n          return function (\n            this: CanvasRenderingContext2D,\n            ...args: Array<unknown>\n          ) {\n            if (!isBlocked(this.canvas, blockClass)) {\n              setTimeout(() => {\n                const recordArgs = [...args];\n                if (prop === 'drawImage') {\n                  if (\n                    recordArgs[0] &&\n                    recordArgs[0] instanceof HTMLCanvasElement\n                  ) {\n                    recordArgs[0] = recordArgs[0].toDataURL();\n                  }\n                }\n                cb({\n                  id: mirror.getId((this.canvas as unknown) as INode),\n                  property: prop,\n                  args: recordArgs,\n                });\n              }, 0);\n            }\n            return original.apply(this, args);\n          };\n        },\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter<CanvasRenderingContext2D>(\n        CanvasRenderingContext2D.prototype,\n        prop,\n        {\n          set(v) {\n            cb({\n              id: mirror.getId((this.canvas as unknown) as INode),\n              property: prop,\n              args: [v],\n              setter: true,\n            });\n          },\n        },\n      );\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\n\nfunction mergeHooks(o: observerParam, hooks: hooksParam) {\n  const {\n    mutationCb,\n    mousemoveCb,\n    mouseInteractionCb,\n    scrollCb,\n    viewportResizeCb,\n    inputCb,\n    mediaInteractionCb,\n    styleSheetRuleCb,\n    canvasMutationCb,\n  } = o;\n  o.mutationCb = (...p: Arguments<mutationCallBack>) => {\n    if (hooks.mutation) {\n      hooks.mutation(...p);\n    }\n    mutationCb(...p);\n  };\n  o.mousemoveCb = (...p: Arguments<mousemoveCallBack>) => {\n    if (hooks.mousemove) {\n      hooks.mousemove(...p);\n    }\n    mousemoveCb(...p);\n  };\n  o.mouseInteractionCb = (...p: Arguments<mouseInteractionCallBack>) => {\n    if (hooks.mouseInteraction) {\n      hooks.mouseInteraction(...p);\n    }\n    mouseInteractionCb(...p);\n  };\n  o.scrollCb = (...p: Arguments<scrollCallback>) => {\n    if (hooks.scroll) {\n      hooks.scroll(...p);\n    }\n    scrollCb(...p);\n  };\n  o.viewportResizeCb = (...p: Arguments<viewportResizeCallback>) => {\n    if (hooks.viewportResize) {\n      hooks.viewportResize(...p);\n    }\n    viewportResizeCb(...p);\n  };\n  o.inputCb = (...p: Arguments<inputCallback>) => {\n    if (hooks.input) {\n      hooks.input(...p);\n    }\n    inputCb(...p);\n  };\n  o.mediaInteractionCb = (...p: Arguments<mediaInteractionCallback>) => {\n    if (hooks.mediaInteaction) {\n      hooks.mediaInteaction(...p);\n    }\n    mediaInteractionCb(...p);\n  };\n  o.styleSheetRuleCb = (...p: Arguments<styleSheetRuleCallback>) => {\n    if (hooks.styleSheetRule) {\n      hooks.styleSheetRule(...p);\n    }\n    styleSheetRuleCb(...p);\n  };\n  o.canvasMutationCb = (...p: Arguments<canvasMutationCallback>) => {\n    if (hooks.canvasMutation) {\n      hooks.canvasMutation(...p);\n    }\n    canvasMutationCb(...p);\n  };\n}\n\nexport default function initObservers(\n  o: observerParam,\n  hooks: hooksParam = {},\n): listenerHandler {\n  mergeHooks(o, hooks);\n  const mutationObserver = initMutationObserver(\n    o.mutationCb,\n    o.blockClass,\n    o.inlineStylesheet,\n    o.maskInputOptions,\n    o.recordCanvas,\n  );\n  const mousemoveHandler = initMoveObserver(o.mousemoveCb, o.sampling);\n  const mouseInteractionHandler = initMouseInteractionObserver(\n    o.mouseInteractionCb,\n    o.blockClass,\n    o.sampling,\n  );\n  const scrollHandler = initScrollObserver(\n    o.scrollCb,\n    o.blockClass,\n    o.sampling,\n  );\n  const viewportResizeHandler = initViewportResizeObserver(o.viewportResizeCb);\n  const inputHandler = initInputObserver(\n    o.inputCb,\n    o.blockClass,\n    o.ignoreClass,\n    o.maskInputOptions,\n    o.sampling,\n  );\n  const mediaInteractionHandler = initMediaInteractionObserver(\n    o.mediaInteractionCb,\n    o.blockClass,\n  );\n  const styleSheetObserver = initStyleSheetObserver(o.styleSheetRuleCb);\n  const canvasMutationObserver = o.recordCanvas\n    ? initCanvasMutationObserver(o.canvasMutationCb, o.blockClass)\n    : () => {};\n\n  return () => {\n    mutationObserver.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    canvasMutationObserver();\n  };\n}\n","import { snapshot, MaskInputOptions } from 'rrweb-snapshot';\nimport initObservers from './observer';\nimport {\n  mirror,\n  on,\n  getWindowWidth,\n  getWindowHeight,\n  polyfill,\n} from '../utils';\nimport {\n  EventType,\n  event,\n  eventWithTime,\n  recordOptions,\n  IncrementalSource,\n  listenerHandler,\n} from '../types';\n\nfunction wrapEvent(e: event): eventWithTime {\n  return {\n    ...e,\n    timestamp: Date.now(),\n  };\n}\n\nlet wrappedEmit!: (e: eventWithTime, isCheckout?: boolean) => void;\n\nfunction record<T = eventWithTime>(\n  options: recordOptions<T> = {},\n): listenerHandler | undefined {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = 'rr-block',\n    ignoreClass = 'rr-ignore',\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    hooks,\n    packFn,\n    sampling = {},\n    mousemoveWait,\n    recordCanvas = false,\n  } = options;\n  // runtime checks for user options\n  if (!emit) {\n    throw new Error('emit function is required');\n  }\n  // move departed options to new options\n  if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\n    sampling.mousemove = mousemoveWait;\n  }\n\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n        }\n      : _maskInputOptions !== undefined\n      ? _maskInputOptions\n      : {};\n\n  polyfill();\n\n  let lastFullSnapshotEvent: eventWithTime;\n  let incrementalSnapshotCount = 0;\n  wrappedEmit = (e: eventWithTime, isCheckout?: boolean) => {\n    emit(((packFn ? packFn(e) : e) as unknown) as T, isCheckout);\n    if (e.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e;\n      incrementalSnapshotCount = 0;\n    } else if (e.type === EventType.IncrementalSnapshot) {\n      incrementalSnapshotCount++;\n      const exceedCount =\n        checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime =\n        checkoutEveryNms &&\n        e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot(true);\n      }\n    }\n  };\n\n  function takeFullSnapshot(isCheckout = false) {\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight(),\n        },\n      }),\n      isCheckout,\n    );\n    const [node, idNodeMap] = snapshot(\n      document,\n      blockClass,\n      inlineStylesheet,\n      maskInputOptions,\n      recordCanvas,\n    );\n\n    if (!node) {\n      return console.warn('Failed to snapshot the document');\n    }\n\n    mirror.map = idNodeMap;\n    wrappedEmit(\n      wrapEvent({\n        type: EventType.FullSnapshot,\n        data: {\n          node,\n          initialOffset: {\n            left:\n              window.pageXOffset !== undefined\n                ? window.pageXOffset\n                : document?.documentElement.scrollLeft ||\n                  document?.body?.parentElement?.scrollLeft ||\n                  document?.body.scrollLeft ||\n                  0,\n            top:\n              window.pageYOffset !== undefined\n                ? window.pageYOffset\n                : document?.documentElement.scrollTop ||\n                  document?.body?.parentElement?.scrollTop ||\n                  document?.body.scrollTop ||\n                  0,\n          },\n        },\n      }),\n    );\n  }\n\n  try {\n    const handlers: listenerHandler[] = [];\n    handlers.push(\n      on('DOMContentLoaded', () => {\n        wrappedEmit(\n          wrapEvent({\n            type: EventType.DomContentLoaded,\n            data: {},\n          }),\n        );\n      }),\n    );\n    const init = () => {\n      takeFullSnapshot();\n\n      handlers.push(\n        initObservers(\n          {\n            mutationCb: (m) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.Mutation,\n                    ...m,\n                  },\n                }),\n              ),\n            mousemoveCb: (positions, source) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source,\n                    positions,\n                  },\n                }),\n              ),\n            mouseInteractionCb: (d) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.MouseInteraction,\n                    ...d,\n                  },\n                }),\n              ),\n            scrollCb: (p) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.Scroll,\n                    ...p,\n                  },\n                }),\n              ),\n            viewportResizeCb: (d) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.ViewportResize,\n                    ...d,\n                  },\n                }),\n              ),\n            inputCb: (v) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.Input,\n                    ...v,\n                  },\n                }),\n              ),\n            mediaInteractionCb: (p) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.MediaInteraction,\n                    ...p,\n                  },\n                }),\n              ),\n            styleSheetRuleCb: (r) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.StyleSheetRule,\n                    ...r,\n                  },\n                }),\n              ),\n            canvasMutationCb: (p) =>\n              wrappedEmit(\n                wrapEvent({\n                  type: EventType.IncrementalSnapshot,\n                  data: {\n                    source: IncrementalSource.CanvasMutation,\n                    ...p,\n                  },\n                }),\n              ),\n            blockClass,\n            ignoreClass,\n            maskInputOptions,\n            inlineStylesheet,\n            sampling,\n            recordCanvas,\n          },\n          hooks,\n        ),\n      );\n    };\n    if (\n      document.readyState === 'interactive' ||\n      document.readyState === 'complete'\n    ) {\n      init();\n    } else {\n      handlers.push(\n        on(\n          'load',\n          () => {\n            wrappedEmit(\n              wrapEvent({\n                type: EventType.Load,\n                data: {},\n              }),\n            );\n            init();\n          },\n          window,\n        ),\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  } catch (error) {\n    // TODO: handle internal error\n    console.warn(error);\n  }\n}\n\nrecord.addCustomEvent = <T>(tag: string, payload: T) => {\n  if (!wrappedEmit) {\n    throw new Error('please add custom event after start recording');\n  }\n  wrappedEmit(\n    wrapEvent({\n      type: EventType.Custom,\n      data: {\n        tag,\n        payload,\n      },\n    }),\n  );\n};\n\nexport default record;\n"],"names":["NodeType","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__values","o","Symbol","iterator","m","next","value","done","TypeError","__read","r","e","ar","push","error","__spread","concat","_id","tagNameRegex","RegExp","getCssRulesString","rules","cssRules","Array","from","reduce","prev","cur","rule","isCSSImportRule","styleSheet","cssText","EventType","IncrementalSource","MouseInteractions","MediaInteractions","ReplayerEvents","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","path1","path2","path3","url","filePath","test","indexOf","split","slice","join","stack","parts","pop","_i","parts_1","part","absoluteToDoc","doc","attributeValue","trim","a","createElement","transformAttribute","name","map","srcItem","urlAndSize","trimLeft","trimRight","getAbsoluteSrcsetString","location","serializeNode","blockClass","inlineStylesheet","maskInputOptions","recordCanvas","nodeType","DOCUMENT_NODE","type","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","ELEMENT_NODE","needBlock_1","classList","contains","forEach","className","tagName","processedTagName","toLowerCase","getValidTagName","attributes_1","_a","attributes","_b","stylesheet","styleSheets","find","rel","_cssText","sheet","innerText","textContent","repeat","checked","selectValue","parentElement","selected","rr_dataURL","toDataURL","rr_mediaState","paused","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","_c","getBoundingClientRect","width","height","rr_width","rr_height","Element","isSVG","el","SVGElement","undefined","needBlock","TEXT_NODE","parentTagName","parentNode","isStyle","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","serializeNodeWithId","skipChild","id","_serializedNode","console","warn","__sn","serializedNode","recordChild","serializedChildNode","on","fn","target","options","capture","passive","addEventListener","removeEventListener","mirror","getId","getNode","removeNodeFromMap","child","has","throttle","func","wait","timeout","previous","arg","now","Date","leading","remaining","context","args","window","clearTimeout","trailing","setTimeout","hookSetter","key","d","isRevoked","win","original","getOwnPropertyDescriptor","defineProperty","set","_this","getWindowHeight","innerHeight","document","documentElement","clientHeight","body","getWindowWidth","innerWidth","clientWidth","isBlocked","node","isTouchEvent","event","Boolean","changedTouches","isNodeInLinkedList","DoubleLinkedList","position","Error","current","head","index","__ln","previousSibling","nextSibling","moveKey","parentId","isINode","cb","Set","mutations","processMutation","addList","getNextId","nextId","pushAdd","addNode","adds","movedSet","_e","addedSet","isAncestorInSet","droppedSet","isParentRemoved","removes","add","candidate","_node","get","removeNode","emit","payload","texts","text","filter","attribute","emissionCallback","movedMap","oldValue","getAttribute","attributeName","item","addedNodes","genAdds","removedNodes","nodeId","deepDelete","isAncestorRemoved","targetId","delete","childN","addsSet","some","initMouseInteractionObserver","sampling","mouseInteraction","disableMap","handlers","keys","Number","isNaN","endsWith","eventKey","eventName","handler","clientX","clientY","x","y","getHandler","h","wrappedEmit","INPUT_TAGS","lastInputValueMap","WeakMap","initCanvasMutationObserver","props","getOwnPropertyNames","CanvasRenderingContext2D","prop","restoreHandler","source","replacement","original_1","wrapped","defineProperties","__rrweb_original__","enumerable","patch","canvas","recordArgs","HTMLCanvasElement","property","hookHandler","v","setter","props_1","initObservers","hooks","mutationCb","mousemoveCb","mouseInteractionCb","scrollCb","viewportResizeCb","inputCb","mediaInteractionCb","styleSheetRuleCb","canvasMutationCb","mutation","mousemove","scroll","viewportResize","input","mediaInteaction","styleSheetRule","canvasMutation","mergeHooks","mutationBuffer","observer","mutationObserver","MutationBuffer","MutationObserver","processMutations","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","mousemoveHandler","timeBaseline","threshold","positions","wrappedCb","isTouch","totalOffset","timeOffset","TouchMove","MouseMove","updatePosition","evt","initMoveObserver","mouseInteractionHandler","scrollHandler","scrollEl","scrollingElement","initScrollObserver","viewportResizeHandler","initViewportResizeObserver","inputHandler","ignoreClass","eventHandler","isChecked","cbWithDedup","querySelectorAll","lastInputValue","propertyDescriptor","HTMLInputElement","hookProperties","HTMLSelectElement","HTMLTextAreaElement","initInputObserver","mediaInteractionHandler","Play","Pause","initMediaInteractionObserver","styleSheetObserver","insertRule","CSSStyleSheet","ownerNode","deleteRule","initStyleSheetObserver","canvasMutationObserver","disconnect","wrapEvent","timestamp","record","checkoutEveryNms","checkoutEveryNth","maskAllInputs","_maskInputOptions","packFn","_d","mousemoveWait","lastFullSnapshotEvent","color","date","datetime-local","email","month","number","range","search","tel","time","week","textarea","select","NodeList","incrementalSnapshotCount","takeFullSnapshot","isCheckout","Meta","data","maskAllInputsOrOptions","idNodeMap","snapshot","FullSnapshot","initialOffset","left","pageXOffset","top","pageYOffset","IncrementalSnapshot","exceedCount","exceedTime","handlers_1","DomContentLoaded","init_1","Mutation","MouseInteraction","Scroll","ViewportResize","Input","MediaInteraction","StyleSheetRule","CanvasMutation","readyState","Load","addCustomEvent","tag","Custom"],"mappings":"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"}